[ { "title": "Welcome to my Site!", "url": "/posts/Welcome/", "categories": "Site", "tags": "important", "date": "2025-01-01 00:00:00 -0500", "snippet": " Hello, and Welcome to my site! I hope you&#39;ll enjoy your time here, and are interested in the projects I&#39;ve worked on! I am not going to be very serious throughout my posts, and hope that you&#39;re not expecting too many serious or &quot;professional&quot; projects. I usually work on stuff that I think is an interesting concept, and is something that will benefit me or be fun to work on. Here&#39;s a few projects I&#39;m particularly proud of if you want some good stuff to check out first Fightboard v2 VETCON Badge RoboDachi This site is still very much a work in progress, so I recommend checking out my GitHub page and checking out each repo separately. (^-^)/ " }, { "title": "FightBoard v2", "url": "/posts/fightboard-v2/", "categories": "Current Projects, FightBoard", "tags": "fightboard, current-projects", "date": "2023-02-27 00:00:00 -0500", "snippet": " 锔 FightBoard v2  GitHub 路 Project Logs NOV 2022 - JAN 2023 No video support.Overview While v1 was a small step into keyboard design, v2 is a giant leap for an upgrade! Not only is v2 about a third the size of v1, but it now includes customizable LED functions, switchable layers, EEPROM storage for remembering states after power loss, and an extra button to customize functions on the fly. Since this is an upgrade, the specs are the same of those of v1 (written in C using QMK firmware, PCB designed in KiCAD, XIAO RP2040) with the figuratively massive change from a throughhole MCP23018 to a literally miniscule surface mount I/O expander. v2 also uses 13 SK6812-MINI LEDs, a TXB0108 level shifter, and a new (custom) keyswitch footprint that allows for soldering on either MX Cherry or Choc hotswap sockets. All of this was worked on during November and December of last year, while the case seen above was mainly worked on in January. Project Purpose This project is the direct upgrade to v1, and some of the features had been planned even before v1 was finished. The main obstacle was the LED circuitry, as not only do they more than double the complexity of the circuit design, but they require 5V for power, which the RP2040 has issues supplying, but can be solved by adding a level shifter to the circuit. Once these issues were solved, the main philosophy of the PCB design was to reduce the overall size, as v2 is meant to be a portable controller. The first step of this was to change component model, as the MCP23018-E/SP was the largest component on the previous design, so I swapped to the E/SS model, which is not only surface mount, but about one fourth of the size. This came with an issue though: the leads were so small, the PCB manufacturer told me they could not place the solder bridge for the part! Luckily, soldering was still possible, just slightly more complicated, so no changes to the design needed to be made. Speaking of component footprints, in order to fit both MX and Choc sockets, I had to create a custom footprint that combined the separate footprints of both of the sockets, with some edits for compatability. Not only that, but I also had to create a completely new footprint for the LEDs, as there was no secure or reliable source for one from the online store I purchased them from. Nonetheless, this was a great chance to begin learning the intricacies of component footprint design, and luckily, both custom footprints worked flawlessly, including the LED footprint which required a rectangular cutout through the entire PCB shaped for the LED body to fit through. I was able to plan for enough tolerance for the LEDs to easily fit into the cutout without enough possible movement to affect PCB assembly. This project was a fantastic opportunity to test my soldering abilities, and I was definitely throwing myself into the deep end. I had little SMT soldering experience, and both the I/O expander and level shifter were much smaller than any part I had ever worked with. Luckily, with admittedly a few mistakes and retries, I was able to fully complete five full boards using both socket types and I now feel much more confident in my soldering skills. Comparison of previous MCP model (left) to current model (right)Pictures of the Project The board without switches, with MX sockets Circuit diagram in KiCAD PCB in KiCAD File Overview matrix.c This file has grown a lot in the upgrade, particularly in order to support optional input handling. Without getting too off topic, the keyboard has a software toggle to handle opposing directional inputs (holding up and down, the keyboard only uses the last pressed). keymap.c Seven layers have added in order to support multiple players on the same firmware, or other games with different control schemes. An RGB LED matrix has also been added for the SK6812-MINIs. v2.c/h This file handles core functions to the keyboard, such as the custom keycodes for layer selection and LED effects, EEPROM configuration/usage, and layer indication. Some functions have been taken from matrix.c for future compatability with the QMK online configurator. Completed Objectives v2, in relation to the design of the main board, is a complete success. Not only is every planned feature available and ready on the current PCB design, but it has been designed with future additions in mind, and some have already been successfully implemented! The upgrade exceeded intial expectations and ideas, and although the case is still work in progress, the main effort of the PCB is complete for this version.Objectives Left Undone Ultimately, the main focus of the upgrade was the PCB design, with the case being a secondary objective, although still highly considered throughout the whole project. Still, the current iteration of the case is definitely not the final, and with certain improvements could bring the case up to the standard set by the PCB. Continuing or Running the Project After installing and setting up QMK using &quot;qmk setup -b develop&quot;, setup the circuit following the KiCAD schematic, and flash the default keymap onto the RP2040. " }, { "title": "FightBoard v1", "url": "/posts/fightboard-v1/", "categories": "Current Projects, FightBoard", "tags": "fightboard, current-projects", "date": "2022-10-24 00:00:00 -0400", "snippet": " 锔 FightBoard v1  GitHub 路 Project Logs AUG 2022 - SEPT 2022Overview The FightBoard is a completely custom mechanical keyboard running QMK firmware, built mainly for use with Fightcade, an arcade game matchmaking tool. Fightboard features 12 hot-swappable Kailh sockets (4 for &quot;WASD&quot; movement, 8 for regular buttons) and 4 pushbuttons for common functions (inputting coins, start, etc). While it is built for use with Fightcade in mind, the FightBoard is a keyboard that can be used with any PC game, or as just a regular keyboard if you only need 12 letters. It runs QMK firmware written in C, on a XIAO Seeeduino RP2040, using a MCP23018 I/O expander and a custom PCB. v1 was originally finished in September, and a final v2 will include addressable RGB LEDs, and an LCD screen, which will hopefully be done within the next few weeks. Project Purpose So, I got a little bit distracted near the end of the summer after hitting a slight roadblock with RoboDachi, so I decided to shift my attention to something I had been interested in for a long time. In fact, I took two of my biggest interests, and smashed them together, those being mechanical keyboards, and fighting games. I designed the FightBoard in order to help familiarize myself with QMK before building a larger scale project. The next version of the FightBoard will hopefully be the final version, and will be include work on a case and metal plate. Pictures of the Project PCB in KiCAD File Overview matrix.c This is the file that handles the I/O expander and the custom matrix. On startup, &quot;matrix_init_custom()&quot; runs and sets up the I/O expander. Afterwards, &quot;matrix_scan_custom()&quot; runs in an infinite loop, and returns True whenever the matrix is different from the last time the function was run. keymap.c This file handles the conversion from 16-bit binary matrix to a usable keymap. The folder can be copied and renamed to create more flashable keymaps that can be used for the same keyboard. Completed Objectives Currently, the main function of the FightBoard is reading from an I/O expander in order to get around matrices and diodes. A lot of effort was also placed in the PCB design and routing. Objectives Left Undone For v1, the only work remaining is designing a case in SolidWorks and 3D printed, but this effort will be saved for work on v2, which will include RGB LEDs and an LCD screen, and hopefully a slightly smaller PCB footprint. Continuing or Running the Project After installing and setting up QMK using &quot;qmk setup -b develop&quot;, setup the circuit following the KiCAD schematic, and flash the default keymap onto the RP2040. Most future changes will happen either to &quot;matrix.c&quot; or either &quot;keymap.c&quot;" }, { "title": "RotomBot&#39;s v3.0 Update", "url": "/posts/rotom-blg-1/", "categories": "Previous Projects, RotomBot", "tags": "rotombot, previous-projects, blog-posts", "date": "2022-07-20 00:00:00 -0400", "snippet": "  RotomBot&#39;s v3.0 Update  GitHub Finally, after a few weeks of struggling to update 2 year old code, I was finally able to update RotomBot to Discord.py v2.0. Honestly, I wouldn&#39;t have bothered as long as it kept running like it had, but I also wanted to add a new command. In order to add what ended up being like a 6 line command, I had to essentially rewrite ALL of rotomBot.py. Good thing I finished it&#39;s write-up last week right? Anyway, Discord.py v2.0 is much better structured (even though I couldn&#39;t get Cogs to work), and any future changes will be easy to make. I kind of hope this is the last update for RotomBot, although I of course still want to maintain it, I also want to move on onto more interesting, larger scale, and productive projects. The whole reason I underwent the ordeal of updating RotomBot is to implement a SICK Button. Quick explanation of what SICK (Server ID Change Kontest) is, basically, every once in a while, my friends and I like to change the appearance of our discord server through contest. In order to decide when to run the contest, I wanted to implement a button that people can press to show interest in running SICK. After the specified amount of people press the button, the bot pings everyone so we can manually run the contest. Maybe one day I can make it so RotomBot also semi-regularly reminds everyone during the week to submit entries, but again, I&#39;m hoping to take a break from RotomBot. " }, { "title": "VETCON Badge", "url": "/posts/vetcon/", "categories": "Previous Projects, Vetcon Badge", "tags": "vetcon-badge, previous-projects", "date": "2022-05-16 00:00:00 -0400", "snippet": "  VETCON  GitHub SEPT 2021 - MAY 2022 Overview This project was assigned to me as my Senior Design Project, and was completed alongside 4 other teammates. This project was much larger in scope than any other project I had ever done, but it was extremely rewarding putting all of the knowledge I have learned over the last 4 years, while also continuing to learn even more along the way. The job assigned to us by our client, VETCON, was to design an electronic badge for them to bring as their unique badge for DEFCON 2022, which is a convention for &quot;security professionals&quot; and &quot;not hackers&quot; to come together and spread their knowledge. The main language used for the project was C++, with some javascript used for some of the games, and the microcontroller at the heart of all of our hardware was the MSP430. If you want indepth write-ups about the project, check out the Hardware Guide and the Software Guide. There are plenty of other reports on the Project GitHub if these aren&#39;t quite what you&#39;re looking for. Project Purpose At first, I expected this project to be similar to EC444, a class based entirely around working with microcontrollers and compatible components, but we were challenged along the entire project. Whether screens were compatible, or whether we could get the device to print to the console successfully and consistently, the hardware challenged us constantly. Not only that, completely new challenges were thrown upon us too, such as designing a completely custom PCB, which ended up becoming my job. This was one of a few challenges we faced that we had little experience with, but I&#39;m glad to say that it was absolutely worth it, and I&#39;ve obtained new skills I&#39;ll definitely use in the future.Picture of the Project" }, { "title": "RoboDachi", "url": "/posts/robodachi/", "categories": "Current Projects, RoboDachi", "tags": "robodachi, current-projects", "date": "2022-05-16 00:00:00 -0400", "snippet": "  RoboDachi  GitHub (private) 路 Project Logs MAY 2022 - Overview This is a project that I&#39;ve been planning for a while now, and incorporates all of what I&#39;ve learned over the last four years. The goal of this project is to design, code and build a functional pocket assistant/friend, RoboDachi, named after Tomogachis, which inspired the idea for this project. This is a massive project for me, as it involves not just coding, but also pcb design, 3D printing, microcontrollers with components completely new to me, and creating a custom graphics library. I&#39;m hoping to make big progress by the end of Summer 2022, but am expecting to be putting a lot of work in this for a long time. Project Purpose This project is one of my babies. I know that sounds weird but hear me out. If successful, RoboDachi will be a completely custom design that I had a hand in working on every single part of, and will not only be a fun toy to play with, but may even help my overall productivity if I can connect it to MiniBot&#39;s (post to come) notifications. What I&#39;m saying is, this is a lifelong project, that I&#39;m not only excited to see what form it ends up in, but the journey I took to get it there, blood, sweat and tears included. Pictures of the Project TODO: Add pictures of the first prototype GFXDesignerApp: A custom application written in C# to help simplify the process of designing and coding the graphics File Overview TODO: GFXDesignerApp TODO: CustomGFX.h/cpp Completed Objectives - Successful electrical connection of FeatherWing and ILI9341 - Rudimentary graphics app to help code graphics library - Basis for graphics library set up - Buttons from Adafruit FeatherWing can be read## Objectives Left Undone - Begin coding personality/Dachi stuff - Design settings and other screens - Design I/O library with joystick and buttons - So much more before I can even think of the next two - Design PCB - Design Case " }, { "title": "MiniBot", "url": "/posts/minibot/", "categories": "Current Projects, MiniBot", "tags": "minibot, current-projects", "date": "2022-02-13 00:00:00 -0500", "snippet": "  MiniBot  GitHub 路 Project Logs Feb 2022 - Overview MiniBot was born out of a purpose. That purpose is to help me remember to do all of the little things I need to do in order to keep my life together. Basically, I needed something to help me remember to take out the trash, wash the dishes, work on important upcoming work, call/message people, etc. Basically, I needed something to help me deal with my poo brain. So, I started working on MiniBot, which is powered mainly by Discord&#39;s API and the Discord.py library. The bot runs continuously on the same RPi as RotomBot , and is a sort of spiritual successor as a lot of what I learned while coding RotomBot went into MiniBot. Project Purpose This project is not much new, but one thing I&#39;ve learned through working on MiniBot is writing timers in Python, that run commands after a certain amount of time. Although I&#39;m relatively comfortable going into this project, maintaining, upgrading, and integrating MiniBot into future projects is something that will be a part of my workload for a long time. Pictures of the Project The RPi that runs MiniBot The UI elements for MiniBot File Overviewminibot.py This is the file run to start the bot, and hosts the two commands that run on bot startup. When the bot is first started, it greets the user in the `#general` channel, connects to MiniBot&#39;s database, and sends the two menu views in the `#menu` channel. The two commands declared in this file call the same menus already sent. m_functions - The real meat of MiniBot that holds most of its functions m_vars.py This tiny file holds all of MiniBot&#39;s global variables, and sets the default variables to their set value. Having this file separate is super handy for testing, as it lets me freely change the timers without worrying about pushing the wrong values to the GitHub branch. Completed Objectives Currently, MiniBot automatically sends two Discord Views that act as menus to add and remove custom reminders or message templates respectively. Also, MiniBot connects to MangaDex&#39;s API to send reminders to the user whenever a new chapter of a manga in a specific list of manga on their site is updated. These three functions are all integrated with each other, and message templates for either reminders or manga releases can be easily added. Objectives Left Undone All initial requirements/goals have been met, yet work on MiniBot is far from over. There are many future plans I have for MiniBot, and it&#39;s functions could also be integrated into some ideas I have for future projects. MiniBot&#39;s future, while unknown, is bright and full of possibilities. Continuing or Running the Project Running MiniBot is just as easy as running RotomBot. Simply make sure you have Python3.9+ installed, download Discord.py v2 from their github, and pip install python-dotenv. Once you do that, put your bot token and guild id into a new `.env` file, and you&#39;re all set! Don&#39;t worry about setting up a database, MiniBot does it automatically. " }, { "title": "m_functions.py", "url": "/posts/m_functions/", "categories": "Current Projects, MiniBot", "tags": "minibot, current-projects", "date": "2022-02-13 00:00:00 -0500", "snippet": "  m_functions.py  Return 路 GitHubFile Overview This file stores all of the functions that MiniBot needs to successfully function. The only non default libraries called are the Discord.py library, and sqlite3 which is used for connecting and maintaining MiniBot&#39;s database. There are also two Discord Views in this file, which are the classes used by MiniBot to create the menus used to modify it&#39;s database through UI instead of code. class Timer This class is super necessary to run, and simple to explain, as the Timer class is the class that instantiates all of the timers MiniBot requires to send its reminders and updates. As inputs, the timer class takes the time until the timer runs, the task it will complete when it does, and any necessary arguments for the task. class reminderView The reminderView class handles the UI for adding any new reminders. The user can use MiniBot to add or remove reminders of two different priorities class messageView The messageView class is very similar to the reminderView class, as they are both menus for adding text to the database. In this menu, the user can add or remove message templates of varying types that are used in varying amounts. class textEnum This is a very simple enum used mainly by messageView and constructMessage() to keep track of the varying types of messages/templates notify_timer() This function is run after the first timer set by MiniBot completes, where it completes its function and runs the next timer for itself. The timer uses most of the global variables from m_vars.py to randomly send either a lower priority reminder, a personality message, or nothing. If nothing has been sent for too long, MiniBot will send a higher priority reminder. manga_timer() This function works similarly to notify_timer(), but instead of sending reminders, this timer checks whether any manga in a specific MangaList on MangaDex has been updated. After comparing the list to the manga in its database, MiniBot sends a message to notify the user or removes the manga from its database if a manga has been updated or removed from the MangaList respectively. getNewestChapter() This function sends a request to the mangadex api, and returns the newest chapter number of the specified manga getMangaInfo() This function is called whenever manga_timer() finds a new chapter for a manga. MiniBot uses this function to get the title and the cover for the message it will send in `#manga-updates` constructMessage() This simple function is called by both timers, and uses getRandomMessage() to add any greeting to any message template to construct the message that will be sent to the user checkConnection() This function is run only once immediately once MiniBot is ready, and checks whether there is a m_db.db file. If there is, MiniBot checks whether all of the necessary tables are built and correct, and builds them if they are not. Then, MiniBot sets the connection to a global variable to be used by any function. add/deleteReminder() get/countReminders() These four functions are extremely simple, as they add or remove reminders from the database, returns all reminders of a specific priority, or returns the amount of reminders in the database respectively add/remove/find/edit/getManga() These functions are all called within manga_timer(), and are the functions used by MiniBot to maintain its database getRandomMessage() This message returns a random notification from MiniBot&#39;s database with a specific priority. It is used mainly in notify_timer() to get the notification to be send to the user add/deleteMessage() / getMessages() These functions are all called by messageView, and they are how MiniBot maintains its message template database Return" }, { "title": "RotomBot", "url": "/posts/rotombot/", "categories": "Previous Projects, RotomBot", "tags": "rotombot, previous-projects", "date": "2021-09-21 00:00:00 -0400", "snippet": "  RotomBot  GitHub June 2020 - Sept 2021 Overview RotomBot was my first major project written in python, and is one of the most extensive projects I&#39;ve worked on so far. This project was extremely helpful in learning the differences between C/C++, which I had experience with during college, and python, which I was learning to use for the first time all the way back in the summer of 2020. Now, that doesn&#39;t mean that RotomBot is written poorly, or that it has few features. RotomBot is a Discord bot written specifically to run on a Raspberry Pi Zero W for a server (or guild if you&#39;ve ever worked on the Discord api) for me and my friends, and serves many different functions, such as a few tools for playing Dungeons and Dragons online, role assignment, and a few admin functions. Project Purpose This project&#39;s original main purpose was to help familiarize myself with Python, but that project outgrew that goal very quickly. I began working on RotomBot near the beginning of the initial pandemic surge in 2020, so many of its functions came into place due to me and my friends&#39; forced distance from each other. Although I became extremely confident in writing in Python, this project never truly became busy work as I was challenged to learn new things and processes at every step of the project. For example, when I first began working on the DDC, essentially a continuous counter that can be incremented or decreased using the bot, I decided it would be best to store the counter in a database. Not only was this just something anyone with a brain would think of, it gave me an opportunity and motivation to learn the intricacies and how to work with databases. Due to this project, I was able to not just become confident in coding in Python, but also with sqLite and database syntax in general. Pictures of the Project The Raspberry Pi Zero W that houses RotomBot RotomBot&#39;s On Ready message sent in #general File Overview rotombot.py - the main file that runs RotomBotCompleted Objectives This project has many functions including all of the DnD related commands. For example, there is an initiative tracker, in which any player can add their character and automatically sort them into the initiative based on their roll. Speaking of rolling, RotomBot also has a customizable dice roll command in case you left your dice downstairs and can&#39;t find enough energy to unstick yourself from your gamer chair. RotomBot also has a few admin functions, such as constant checking of a &quot;#pick-roles&quot; channel, where admins can send specific messages, and RotomBot will react to the message. Any user who reacts to the message will recieve the corresponding reaction, and it will be removed when the user removes their reaction. There are many more functions and specifics, but a more in-depth view of the project&#39;s commands can be read in the file overview Objectives Left Undone Although I am a firm believer that software is never truly finished, I see RotomBot as a sort of finished project/ living piece of software. This means that although I don&#39;t have many remaining plans to continue working on the project, I will not only continue to mainain it and optimize it when necessary, but will continue to work on RotomBot when any new/good ideas come up. One remaining objective would be automatic setup of new database tables on restart, but that&#39;s a bridge that I&#39;ll worry about crossing later. Continuing or Running the Project RotomBot is a relatively easy project to set up, whether to improve on it or just to run it for yourself. Simply make sure you have Python3.9+ installed, download Discord.py v2 from their github, and pip install python-dotenv. Once you do that, put your bot token and guild id into a new `.env` file, set up a new database, and you&#39;re all set!" }, { "title": "rotombot.py", "url": "/posts/rotomOV/", "categories": "Previous Projects, RotomBot", "tags": "rotombot, previous-projects, overviews", "date": "2021-09-21 00:00:00 -0400", "snippet": " 锔 rotombot.py 锔 Return 路 GitHub This file is the brain, body, and soul of RotomBot. Normally, I prefer to spread out by functions and main initializations, but in this case, most of RotomBot lives in the main file. All important global variables are also declared and initialized in this file, the most important being `TOKEN` and `guild_id`, which are the bot token and the main guild it&#39;s working in respectively. Event Listenersbot.event - on_ready() This function runs whenever the bot connects or reconnects to the discord api and &quot;is ready&quot; to begin functioning. First, the bot assigns the `guild` global variable, which will be frequently used by many commands. The bot then sets up the presence it will use on the Discord sidebar, and check whether it is being run for the first time. If it is, it creates the connection with the database and sets it to the global variable con, and sends a message in the `#general` channel of the Discord server. bot.event - on_member_join() This is an extremely simple event handler, where RotomBot will send an introductory message to any user joining the server for the first time. bot.listen - register_reaction(): Role Assignment This function pulls double duty, as the first half of it pictured above is related to the role assignment functions of the bot, while the second half relates to the server suggestions function. Essentially, this half listens to every message send in the `#pick-roles` channel, and automatically reacts to that message with every emote in the message. When it does so, it adds every emote and corresponding role with the message id to the database. This will allow future users to use the bot&#39;s reactions to assign themselves the available roles through RotomBot. bot.listen - register_reaction(): Server Suggestions The other half of register_reaction() is somewhat of a misnomer, as it was written way after the role request function of the event listener. If a user sends a message in the `#server-suggestions` channel that mentions the `Admin` role, RotomBot will automatically resend that message in the `#admin-chat` channel to make sure the suggestion gets seen. bot.listen - remove/edit_reactions() Both of these event listeners work in tandem to help admin&#39;s setting up or organizing the `#pick-roles` channel. remove_reactions() is called whenever a message is deleted from the channel, and removes the database entries related to it. edit_reactions is called whenever a message is editted, and ensures that all old database entries are removed, and the new editted entries are added to the database. bot.listen - reaction_un/listener(): These two listeners are somewhat two sides of the same coin that are the basis of RotomBot&#39;s role assignment functionality. While reaction_listener() listens to any reactions in the `#pick-roles` channel and adds the corresponding role to the user, reaction_unlistener() does the opposite, and listens to any reaction removals, and removes the corresponding role from the user. class dndroll() This command is RotomBot&#39;s dice roll function which allows any user to roll a die of any size and automatically add any roll modifier. Most of the function is based around string manipulation, as the only input is the command call. ddc(): view() All of the Destroyed Dimension Counter (DDC) functions relate to an inside joke with my friends, but the basis of it is that it is a continuous tracker that we can easily add to or subtract from, or in this case, print out the current value. ddc(): add(), sub() These are the two functions that add and subtract from the DDC, as long as the user has the `fellowship` role in the server.init(): start() This command handles creating or resetting a virtual combat initiative order for Dungeons and Dragons. It&#39;s necessary for the DM to call this before any player attempts to add their character init(): add(), remove() These commands are called by players and DMs who want to add characters to the virtual initiative. The character&#39;s name should be inputted, alongside their initiative roll (with DEX modifier as decimal for accuracy), and an optional boolian flag that handles hiding characters from the players. init(): view(), next() The view command prints out the entire virtual initiative order for players and/or DMs to view, and depending on the user, includes or excludes hidden characters. Continuing beyond the first character in the initiative tracker is handled by the next command, which is essential for the condition tracker to function. condition(): add(), remove() These commands add and remove any condition with a specified duration applied to a specific character. The condition tracker as a whole works in conjunction with the initiative tracker. keepwatch() This command sends out a message that helps DMs keep track of characters keeping watch in a camp scenarion. inventory() This command brings up the inventory menu, which the bot sends in a message. This menu can be used to keep track of character or party inventories, including the money separately from their stuff. class serverchangelog() Simply this command sends a message in the server containing either the entire changelog for the bot, or just for the most recent update. shutdown() This command completely shuts down RotomBot, but can only be called by me, its one true master &amp;gt;:) class miscrepeat() Fun fact, this was the first command ever written for RotomBot, and has barely ever changed since it was written. All it does is take any input after the command call, and replaces the entire message as its own. Return" } ]
